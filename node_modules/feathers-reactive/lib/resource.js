'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paramsPositions = undefined;

exports.default = function (Rx, events, settings, method) {
  return function () {
    var result = this._super.apply(this, arguments);

    var position = typeof paramsPositions[method] !== 'undefined' ? paramsPositions[method] : 1;
    var params = arguments[position] || {};

    if (this._rx === false || params.rx === false || typeof result.then !== 'function') {
      return result;
    }

    var options = Object.assign({}, settings, this._rx, params.rx);
    var source = Rx.Observable.fromPromise(result);
    var stream = source.concat(source.exhaustMap(function (data) {
      // Filter only data with the same id
      var filter = function filter(current) {
        return current[options.idField] === data[options.idField];
      };
      // `removed` events get special treatment
      var filteredRemoves = events.removed.filter(filter);
      // `created`, `updated` and `patched`
      var filteredEvents = Rx.Observable.merge(events.created, events.updated, events.patched).filter(filter);

      return Rx.Observable.merge(
      // Map to a callback that merges old and new data
      filteredEvents.map(function (newItem) {
        return function (oldItem) {
          return options.merge(oldItem, newItem);
        };
      }),
      // filtered `removed` events always map to a function that returns `null`
      filteredRemoves.map(function () {
        return function () {
          return null;
        };
      })).scan(function (current, callback) {
        return callback(current);
      }, data);
    }));

    return (0, _utils.promisify)(stream, result);
  };
};

var _utils = require('./utils');

// The position of the params parameters for a service method so that we can extend them
// default is 1
var paramsPositions = exports.paramsPositions = {
  update: 2,
  patch: 2
};